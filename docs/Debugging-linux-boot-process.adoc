= üìö Debugging Linux Boot Process
:toc:
:toclevels: 4
:toc-title: Table of Contents
:icons: font
:source-highlighter: highlightjs
:numbered:
:imagesdir: ../images

[abstract]
This document is about understanding how to decompress the kernel, load it into memory, and execute it. We build the QEMU ARM image by following the steps given in the `link:https://github.com/Abhishekojha38/yocto-playground.git[yocto-playground]` repository.

We will start this journey by analysing the zImage and understanding that how zImage is created.

== üîç Analyse the zImage

[TIP]
====
We already built the QEMU image and yocot SDK in advance. Now, Setup the environment.
====

. We already built the QEMU image and yocot SDK in advance. Now, Setup the environment.
+
[source,bash]
----
source /opt/playground-arm/1.0/environment-setup-cortexa15t2hf-neon-poky-linux-gnueabi
cd yocto-playground/build-playground-arm/tmp/work/playground_arm-poky-linux-gnueabi/linux-playground/6.12.56
----

. when we run the make ARCH=arm zImage command, it will generate the zImage file from the vmlinux file by following certain steps which are explained in the next section.
+
[source,bash]
----
make ARCH=arm zImage
----

image::zImage.png[]

[cols="1,3,2", options="header"]
|===
| File Name | Description | Path

| vmlinux
| An ELF-format binary. This is the original and uncompressed kernel image.
| ./vmlinux

| System.map
| A lookup table mapping symbol names to their corresponding memory addresses, mainly used for debugging and symbol resolution.
| ./System.map

| Image
| Generated from vmlinux using objcopy, extracting only executable machine code
(removing comments and debugging symbols).
At this stage, the Image is not directly executable because required metadata has not yet been added.
| ./arch/arm/boot/Image

| head.o
| ARM-specific startup code responsible for taking over system control from the bootloader.
The source file head.S is written in ARM assembly.
| ./arch/arm/boot/compressed/head.S

| piggy.gzip
| The Image compressed using gzip.
| ./arch/arm/boot/compressed/piggy.gzip

| piggy.gzip.o
| An assembly-written object file that allows piggy.gzip to be linked with other objects.
| ./arch/arm/boot/compressed/piggy.gzip.S

| misc.o
| Contains the decompression logic used to unpack the compressed kernel image.
| ./arch/arm/boot/compressed/misc.c

| compressed/vmlinux
| A kernel image generated by combining System.map and other files.
Its meaning differs from the original vmlinux, as it is intended for the compressed boot stage.
| ./arch/arm/boot/compressed/vmlinux

| zImage
| The final kernel image. It is compressed and ready to be loaded and executed by the bootloader.
| ./arch/arm/boot/zImage

|===

image::kernel-bootstrap.png[]

=== ‚öôÔ∏è Step 1: Image

`objcopy` is used to generate a binary file:

* `-R`: Removes the section named `.comment` from the ELF file (`vmlinux`).
* `-S`: Strips debug symbols.

[source,bash]
----
# Generate Image
arm-poky-linux-gnueabi-objcopy -O binary -R .comment -S  vmlinux Image
----

=== üóúÔ∏è Step 2: piggy.gzip

The Image is compressed with gzip into piggy.gzip. Does this mean that if gzip fails, piggy.gzip will be deleted?

[source,bash]
----
(cat Image | gzip -n -f -9 > arch/arm/boot/compressed/piggy.gzip) || (rm -f arch/arm/boot/compressed/piggy.gzip ;false)
----

=== üîó Step 3: piggy.gzip.o

[source,bash]
----
arm-poky-linux-gnueabi-gcc -Wp,-MD,arch/arm/boot/compressed/.piggy.gzip.o.d \
                -nostdinc -isystem  -DCC_HAVE_ASM_GOTO  \
                -DZIMAGE -c -o arch/arm/boot/compressed/piggy.gzip.o \
                ../git/arch/arm/boot/compressed/piggy.S
----

image::piggy-linker-script.png[]

The two labels, input_data and input_data_end, are used as boundaries (only the binary data between these two labels is what gets loaded).
From this, we can roughly understand that the purpose of piggy.gzip.S is to provide piggy.gzip to the startup code that runs before the kernel image is loaded (the name piggy implies "carrying on the back")

=== üöÄ Step 4: Bootstrap loader

If the bootloader is considered the first half, then the bootstrap loader is the second half. Its main responsibilities are:

* Initializing the CPU/SoC and the required memory.
* Decompressing the kernel image (if it is compressed; some bootstrap loaders also verify correctness using a checksum) and placing it in memory.
* Loading the decompressed kernel image.

[NOTE]
====
The difference between the bootloader and the bootstrap loader is that the former starts running as soon as power is applied and does not depend on the kernel, while the latter exists in the transitional phase between the end of the bootloader and the handoff to the kernel.
====

We can summarize the bootstrap loader flow as follows:

* When the bootloader hands over control, head.o (along with related files) takes control and begins processor-specific initialization (enabling special instructions or caches, disabling interrupts, etc.).
* misc.o locates and decompresses the Image using information from piggy.gzip.S.
* Other processor-specific initialization steps are performed.
* The Image is loaded.

=== üìù Boot message

This snapshot shows the function used for decompressing the kernel image.

image::decompress-kernel-function.png[]

== üîÑ Initialization Flow

image::kernel-initialization-graph.png[]

=== üìã head.S

We have already captured `head.o` in the previous step. Now we will see the assembly code of `head.S` and analyse it using QEMU and gdb.

The file `arch/arm/boot/compressed/head.S` is the entry point for the compressed kernel (`zImage`). It is responsible for:

* **Initial Setup**: Setting up the processor state and basic environment.
* **Stack Setup**: Initializing the stack pointer for the decompression routine.
* **Decompression**: Calling the `decompress_kernel` function in `misc.c`.
* **Relocation**: Moving the kernel if it was loaded at a conflicting address.
* **Execution**: Jumping to the start of the decompressed kernel image.

After building the image we will launch qemu with the following command.

image::launch-qemu-with-gdb.png[]

Now QEMU is waiting for the GDB connection. The `-S` option freezes the CPU at startup, and the `-s` option starts the GDB server on port 1234. We will connect to it using the following command.

image::run-gdb.png[]

Connect the gdb to qemu by executing the following command in gdb 

[source,bash]
----
target remote :1234
----

* Here Image loading address is 0x40000000 and we will try to display the memory at this address.

[source,bash]
----
0x40000010: .word  <machine_type or 0>
0x40000014: .word  <dtb_phys_addr>
0x40000018: .word  <kernel_entry_point>
----

[cols="1,3", options="header"]
|===
| Register | Meaning

| r0
| Must be 0

| r1
| Machine ID (old) **or 0**

| r2
| Physical address of DTB

| pc
| Jump to kernel entry
|===

image::dump-pc.png[]

[source,assembly]
----
ldr     pc, [pc, #4]    ; 0x40000018
----

image::move-pc-to-next-inst-1.png[]

==== ‚è≠Ô∏è nops instructions

Execution begins in `arch/arm/boot/compressed/head.S` at the `start` symbol. For legacy reasons, the code starts with 7 or 8 `NOP` instructions.

image::move-pc-to-next-inst-2.png[]

`0x40010000` is the `.text` section.

[TIP]
====
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm/boot/compressed/head.S#n188
====

To understand the process in more detail, let's dive into the `vmlinux` binary and examine its sections and disassembly.

*vmlinux disassembly*

image::vmlinux-disassembly.png[]

To get more details info in gdb we will load the vmlinux at the right location which is our .text section.

image::load-symbols-vmlinux.png[]

image::gdb-vmlinux-symbols.png[]

==== ‚è≠Ô∏è ATAGS and Arch ID
`head.S` execution sequence jumps over some magic numbers and saves the pointer to the ATAGs.

image::head.s-atags.png[]

image::save-atags.png[]

Display R1 and r2 register values to see the ATAGS and Arch ID.

`Arch ID = 0xffffffff`
`ATAGS = 0x48000000`

image::arch-id-atags-pointer.png[]

==== üõ°Ô∏è Enter SVC mode and disable IRQ/FIQ

`safe_svcmode_maskall r0`  This macro is intended for forcing the CPU into SVC mode at boot time.

image::enter-svc-mode.png[]

image::svc-r0-cpsr.png[]

`msr	spsr_cxsf, r9` saves the CPU boot mode in `SPSR`

[source,assembly]
----
0x1d3 = 0000 0000 0000 0000 0000 0001 1101 0011
                                   ^^^^^
                                   1 1101 0011

0x1d3 & 0x1f = 0x13 -> Supervisor (SVC) mode
0x1d3 & 0xc0 = 0xc0 -> IRQ and FIQ disabled
State ARM
NZCV flags are set to 0
----

==== üìç Locate the start of physical memory

After saving the ATAGS and Arch ID, we will execute the decompression routine.So now the kernel decompression code is executing from the physical address of the physical memory where it was loaded.

The decompression code then locates the start of physical memory. On most modern platforms this is done with the Kconfig-selected code AUTO_ZRELADDR, which means a logical AND between the program counter and 0xf8000000. This means that the kernel readily assumes that it has been loaded and executed in the first part of the first block of physical memory.

image::find-physical-memory.png[]

once instructions are excuted, we know the starting address of the physical memory.

[source,instructions]
----
mov	r0, pc
and	r0, r0, #0xf8000000
----

image::find-phy-addr.png[]

`0x40000000` is the starting address of the physical memory.

The kernel image is loaded somewhere in physical memory, often by a bootloader (U-Boot, or in some old systems, Angel).The kernel doesn't know the exact load address yet. But it needs a base address for:

* Setting up the stack (sp)
* Copying itself to the proper location
* Accessing global data and relocation info
So early boot uses PC-relative addressing to calculate a safe "kernel base" address.

The decompression code needs a base address to work from, because it will eventually:

* Copy itself to the right place
* Set up the stack
* Jump into C code

[source,calculation]
----
0xf8000000 = 1111 1000 0000 0000 0000 0000 0000 0000
Top 5 bits = physical memory block
Lower 27 bits = offset within the block
----

*So pc & 0xf8000000 keeps the first 32MB-aligned block of memory*

*Example*

Suppose kernel is loaded at:
PC = 0x400100a4
Compute:
0x400100a4 & 0xf8000000 = 0x40000000
0x40000000 ‚Üí kernel base address
All PC-relative offsets can now be computed from here safely.

==== üìä Calculate stack top address

. Below instructions are from head.S file which takes care of stack top address calculation.
+
[source,instruction]
----
adr r1, LC1
ldr sp, [r1]    @ get stack location
add sp, sp, r1  @ apply relocation
----

. To understand the LC1 label we will use objdump.
+
[source,instruction]
----
arm-poky-linux-gnueabi-objdump -D arch/arm/boot/compressed/vmlinux |less

ADDRESS <symbol_name>:
   OFFSET:   MACHINE_CODE    DISASSEMBLED_INSTRUCTION
----

image::LC0-LC1.png[]

This instruction from head.S will be converted to

image::of-use.png[]

Now here current instruction address is `0x400100a8` and Value of pc during execution is `0x400100a8 + 8 = 0x400100b0`. Add `   0x200` to it to get the final value **0x400102b0**.

image::stack-location.png[]

image::stack-location-gdb.png[]

[source,instruction]
----
add r1, pc, #512    @ r1 = PC + 0x200
----

Here is the values of r1 and PC register before execution of first instruction. We can see that r1 address is `0x400102b0` which is matching with the value in the objdump output LC1: 0x000002b0

image::of-use-1.png[]

[source,instruction]
----
ldr sp, [r1]         @ sp = [r1]
----

Here is the value of sp register after execution of above instruction.

image::sp-before-relocation.png[]

At this point in GDB, we have just done the ldr sp, [r1], but not yet the relocation (add sp, sp, r1)
That's why SP = 0x9faa10 ‚Üí it is the offset read from memory, not the final absolute address.

image::sp-after-relocation.png[]

Now we have the final absolute address of the stack.

```bash
sp_final = 0x009faa10 + 0x400102b0
         = 0x40a0acc0
```

Stack caluculation was bit tricky to undestand and that's why I am adding more details to it.

**LC1 and .L_user_stack_end Offset Analysis (ARM zImage Decompressor)**

`.L_user_stack_end` is *not* a linker symbol.

It is a **local assembler label** defined in `head.S`.

Instead, its value is derived from the end of the `.stack` section.

The LC1 object stores *relative offsets*:

----
LC1[0] = .L_user_stack_end - LC1
LC1[1] = _edata - LC1
----

At runtime:

----
real_address = LC1_address + stored_offset
----

This allows the decompressor to remain fully position-independent.

---

*Section Layout (readelf)*

Command:

----
arm-poky-linux-gnueabi-readelf -S arch/arm/boot/compressed/vmlinux
----

Output:

----
There are 24 section headers, starting at offset 0xa17c04:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 001000 006368 00  AX  0   0 32
  [ 2] .table            PROGBITS        00006368 007368 00001c 00  WA  0   0  4
  [ 3] .rodata           PROGBITS        00006384 007384 000da8 00   A  0   0  4
  [ 4] .piggydata        PROGBITS        0000712c 00812c 9f2b47 00   A  0   0  1
  [ 5] .got.plt          PROGBITS        009f9c74 9fac74 00000c 04  WA  0   0  4
  [ 6] .got              PROGBITS        009f9c80 9fac80 000024 00  WA  0   0  4
  [ 7] .pad              PROGBITS        009f9ca4 9faca4 000004 00   A  0   0  1
  [ 8] .bss              NOBITS          009f9ca8 9faca8 000018 00  WA  0   0  4
  [ 9] .stack            NOBITS          009f9cc0 9faca8 001000 00  WA  0   0  1
----

Important values:

----
.stack Addr = 0x009f9cc0
.stack Size = 0x1000
----

Therefore:

----
.L_user_stack_end = 0x009f9cc0 + 0x1000
                 = 0x009facc0
----

*Symbol Lookup (nm)*

Commands:

----
arm-poky-linux-gnueabi-nm -n arch/arm/boot/compressed/vmlinux |grep LC1
----

Output:

----
000002b0 t LC1
----

Additional symbols:

----
arm-poky-linux-gnueabi-nm -n arch/arm/boot/compressed/vmlinux |egrep "LC1|_edata|_start"
----

Output:

----
00000000 T _magic_start
00000000 T _start
000002b0 t LC1
00005cec T fdt_check_mem_start
00006368 D _table_start
009f9c80 D _got_start
009f9ca8 B __bss_start
009f9ca8 R _edata
009f9ca8 R _edata_rea
----

So:

----
LC1     = 0x000002b0
_edata  = 0x009f9ca8
----

Compute:

----
_edata - LC1 = 0x009f9ca8 - 0x2b0 = 0x009f99f8
----

*Raw LC1 Contents (objdump)*

Command:

----
arm-poky-linux-gnueabi-objdump -s -j .text arch/arm/boot/compressed/vmlinux |grep "02b0 "
----

Output:

----
 02b0 10aa9f00 f8999f00 e4dbaf00 b3999f00  ................
----

Little endian decoding:

----
Word0 = 0x009faa10
Word1 = 0x009f99f8
----

*LC1 Disassembly Context*

Command:

----
arm-poky-linux-gnueabi-objdump -D arch/arm/boot/compressed/vmlinux |grep -A6 LC1
----

Output:

----
      c8:       359f01e8        ldrcc   r0, [pc, #488]  @ 2b8 <LC1+0x8>
      cc:       3080000f        addcc   r0, r0, pc
      d0:       31540000        cmpcc   r4, r0
      d4:       33844001        orrcc   r4, r4, #1
      d8:       2b000078        blcs    2c0 <cache_on>

000000dc <restart>:
--
000002b0 <LC1>:
     2b0:       009faa10
     2b4:       009f99f8
     2b8:       00afdbe4
     2bc:       009f99b3

000002c0 <cache_on>:
----

*Stack Offset Calculation*

From earlier:

----
.L_user_stack_end = 0x009facc0
LC1               = 0x000002b0
----

Compute:

----
.L_user_stack_end - LC1
= 0x009facc0 - 0x2b0
= 0x009faa10
----

This matches LC1[0]:

----
009faa10
----

*Final Interpretation of LC1*

LC1 contains:

----
LC1[0] = 0x009faa10  -> (.L_user_stack_end - LC1)
LC1[1] = 0x009f99f8  -> (_edata - LC1)
----

At runtime:

----
sp = LC1 + LC1[0]
r6 = LC1 + LC1[1]
----

Which reconstructs:

* stack top
* end of image

without absolute addresses.

Final values for this build:

----
.stack Addr = 0x009f9cc0
.stack Size = 0x1000

.L_user_stack_end = 0x009facc0
LC1 = 0x2b0

Stack Offset = 0x009faa10
_edata Offset = 0x009f99f8
----

Everything matches exactly.

Next we check if we would overwrite the compressed kernel with the uncompressed kernel. That would be unfortunate. If this would happen, we check where in the memory the uncompressed kernel would end, and then we copy ourselves (the compressed kernel) past that location.

Then the code simply does a trick to jump back to the relocated address of a label called restart: which is the start of the code to set up the stack pointer and malloc() area, but now executing at the new physical address.

We have the kernel base address now. Next step is to add the TEXT_OFFSET to it to get the kernel base address.
Then the TEXT_OFFSET is added to the pointer to the start of physical memory. As the name says, this is where the kernel .text segment (as output from the compiler) should be located. The .text segment contains the executable code so this is the actual starting address of the kernel after decompression. The TEXT_OFFSET is usually 0x8000 so the kernel will be located 0x8000 bytes into the physical memory. This is defined in arch/arm/Makefile.

image::textofs.png[]

This snapshot is from arch/arm/Makefile. TEXT_OFFSET is 0x8000 by default

[NOTE]
====
The 0x8000 (32KB) offset is a convention, because usually there is some immobile architecture-specific data placed at 0x00000000 such as interrupt vectors, and many elder systems place the ATAGs at 0x00000100. There also must be some space, because when the kernel finally boots, it will subtract 0x4000 (or 0x5000 for LPAE) from this address and store the initial kernel page table there.
====

This means it will again set up the stack and malloc() area and look for the appended DTB and everything will look like the kernel was loaded in this location to begin with. (With one difference though: we have already augmented the DTB with ATAGs, so that will not be done again.) This time the uncompressed kernel will not overwrite the compressed kernel.

image::restart-function.png[]

image::setup-sp.png[]

```bash

          /* malloc space is above the relocated stack (64k max) */                                                                                                                                         
          add r10, sp, #MALLOC_SIZE  
```

image::malloc-space.png[]