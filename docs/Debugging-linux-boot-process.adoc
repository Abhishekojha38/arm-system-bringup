= üìö Debugging Linux Boot Process
:toc:
:toclevels: 4
:toc-title: Table of Contents
:icons: font
:source-highlighter: highlightjs
:numbered:
:imagesdir: ../images

[abstract]
This document is about understanding how to decompress the kernel, load it into memory, and execute it. We build the QEMU ARM image by following the steps given in the `link:https://github.com/Abhishekojha38/yocto-playground.git[yocto-playground]` repository.

We will start this journey by analysing the zImage and understanding that how zImage is created.

== üîç Analyse the zImage

[TIP]
====
We already built the QEMU image and yocot SDK in advance. Now, Setup the environment.
====

. We already built the QEMU image and yocot SDK in advance. Now, Setup the environment.
+
[source,bash]
----
source /opt/playground-arm/1.0/environment-setup-cortexa15t2hf-neon-poky-linux-gnueabi
cd yocto-playground/build-playground-arm/tmp/work/playground_arm-poky-linux-gnueabi/linux-playground/6.12.56
----

. when we run the make ARCH=arm zImage command, it will generate the zImage file from the vmlinux file by following certain steps which are explained in the next section.
+
[source,bash]
----
make ARCH=arm zImage
----

image::zImage.png[]

[cols="1,3,2", options="header"]
|===
| File Name | Description | Path

| vmlinux
| An ELF-format binary. This is the original and uncompressed kernel image.
| ./vmlinux

| System.map
| A lookup table mapping symbol names to their corresponding memory addresses, mainly used for debugging and symbol resolution.
| ./System.map

| Image
| Generated from vmlinux using objcopy, extracting only executable machine code
(removing comments and debugging symbols).
At this stage, the Image is not directly executable because required metadata has not yet been added.
| ./arch/arm/boot/Image

| head.o
| ARM-specific startup code responsible for taking over system control from the bootloader.
The source file head.S is written in ARM assembly.
| ./arch/arm/boot/compressed/head.S

| piggy.gzip
| The Image compressed using gzip.
| ./arch/arm/boot/compressed/piggy.gzip

| piggy.gzip.o
| An assembly-written object file that allows piggy.gzip to be linked with other objects.
| ./arch/arm/boot/compressed/piggy.gzip.S

| misc.o
| Contains the decompression logic used to unpack the compressed kernel image.
| ./arch/arm/boot/compressed/misc.c

| compressed/vmlinux
| A kernel image generated by combining System.map and other files.
Its meaning differs from the original vmlinux, as it is intended for the compressed boot stage.
| ./arch/arm/boot/compressed/vmlinux

| zImage
| The final kernel image. It is compressed and ready to be loaded and executed by the bootloader.
| ./arch/arm/boot/zImage

|===

image::kernel-bootstrap.png[]

=== ‚öôÔ∏è Step 1: Image

`objcopy` is used to generate a binary file:

* `-R`: Removes the section named `.comment` from the ELF file (`vmlinux`).
* `-S`: Strips debug symbols.

[source,bash]
----
# Generate Image
arm-poky-linux-gnueabi-objcopy -O binary -R .comment -S  vmlinux Image
----

=== üóúÔ∏è Step 2: piggy.gzip

The Image is compressed with gzip into piggy.gzip. Does this mean that if gzip fails, piggy.gzip will be deleted?

[source,bash]
----
(cat Image | gzip -n -f -9 > arch/arm/boot/compressed/piggy.gzip) || (rm -f arch/arm/boot/compressed/piggy.gzip ;false)
----

=== üîó Step 3: piggy.gzip.o

[source,bash]
----
arm-poky-linux-gnueabi-gcc -Wp,-MD,arch/arm/boot/compressed/.piggy.gzip.o.d \
                -nostdinc -isystem  -DCC_HAVE_ASM_GOTO  \
                -DZIMAGE -c -o arch/arm/boot/compressed/piggy.gzip.o \
                ../git/arch/arm/boot/compressed/piggy.S
----

image::piggy-linker-script.png[]

The two labels, input_data and input_data_end, are used as boundaries (only the binary data between these two labels is what gets loaded).
From this, we can roughly understand that the purpose of piggy.gzip.S is to provide piggy.gzip to the startup code that runs before the kernel image is loaded (the name piggy implies "carrying on the back")

=== üöÄ Step 4: Bootstrap loader

If the bootloader is considered the first half, then the bootstrap loader is the second half. Its main responsibilities are:

* Initializing the CPU/SoC and the required memory.
* Decompressing the kernel image (if it is compressed; some bootstrap loaders also verify correctness using a checksum) and placing it in memory.
* Loading the decompressed kernel image.

[NOTE]
====
The difference between the bootloader and the bootstrap loader is that the former starts running as soon as power is applied and does not depend on the kernel, while the latter exists in the transitional phase between the end of the bootloader and the handoff to the kernel.
====

We can summarize the bootstrap loader flow as follows:

* When the bootloader hands over control, head.o (along with related files) takes control and begins processor-specific initialization (enabling special instructions or caches, disabling interrupts, etc.).
* misc.o locates and decompresses the Image using information from piggy.gzip.S.
* Other processor-specific initialization steps are performed.
* The Image is loaded.

=== üìù Boot message

This snapshot shows the function used for decompressing the kernel image.

image::decompress-kernel-function.png[]

== üîÑ Initialization Flow

image::kernel-initialization-graph.png[]

=== üìã head.S

We have already captured `head.o` in the previous step. Now we will see the assembly code of `head.S` and analyse it using QEMU and gdb.

The file `arch/arm/boot/compressed/head.S` is the entry point for the compressed kernel (`zImage`). It is responsible for:

* **Initial Setup**: Setting up the processor state and basic environment.
* **Stack Setup**: Initializing the stack pointer for the decompression routine.
* **Decompression**: Calling the `decompress_kernel` function in `misc.c`.
* **Relocation**: Moving the kernel if it was loaded at a conflicting address.
* **Execution**: Jumping to the start of the decompressed kernel image.

After building the image we will launch qemu with the following command.

image::launch-qemu-with-gdb.png[]

Now QEMU is waiting for the GDB connection. The `-S` option freezes the CPU at startup, and the `-s` option starts the GDB server on port 1234. We will connect to it using the following command.

image::run-gdb.png[]

Connect the gdb to qemu by executing the following command in gdb 

[source,bash]
----
target remote :1234
----

* Here Image loading address is 0x40000000 and we will try to display the memory at this address.

[source,bash]
----
0x40000010: .word  <machine_type or 0>
0x40000014: .word  <dtb_phys_addr>
0x40000018: .word  <kernel_entry_point>
----

[cols="1,3", options="header"]
|===
| Register | Meaning

| r0
| Must be 0

| r1
| Machine ID (old) **or 0**

| r2
| Physical address of DTB

| pc
| Jump to kernel entry
|===

image::dump-pc.png[]

[source,assembly]
----
ldr     pc, [pc, #4]    ; 0x40000018
----

image::move-pc-to-next-inst-1.png[]

==== ‚è≠Ô∏è nops instructions

Execution begins in `arch/arm/boot/compressed/head.S` at the `start` symbol. For legacy reasons, the code starts with 7 or 8 `NOP` instructions.

image::move-pc-to-next-inst-2.png[]

`0x40010000` is the `.text` section.

[TIP]
====
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/arm/boot/compressed/head.S#n188
====

To understand the process in more detail, let's dive into the `vmlinux` binary and examine its sections and disassembly.

*vmlinux disassembly*

image::vmlinux-disassembly.png[]

To get more details info in gdb we will load the vmlinux at the right location which is our .text section.

image::load-symbols-vmlinux.png[]

image::gdb-vmlinux-symbols.png[]

==== ‚è≠Ô∏è ATAGS and Arch ID
`head.S` execution sequence jumps over some magic numbers and saves the pointer to the ATAGs.

image::head.s-atags.png[]

image::save-atags.png[]

Display R1 and r2 register values to see the ATAGS and Arch ID.

`Arch ID = 0xffffffff`
`ATAGS = 0x48000000`

image::arch-id-atags-pointer.png[]

==== üõ°Ô∏è Enter SVC mode and disable IRQ/FIQ

`safe_svcmode_maskall r0`  This macro is intended for forcing the CPU into SVC mode at boot time.

image::enter-svc-mode.png[]

image::svc-r0-cpsr.png[]

`msr	spsr_cxsf, r9` saves the CPU boot mode in `SPSR`

[source,assembly]
----
0x1d3 = 0000 0000 0000 0000 0000 0001 1101 0011
                                   ^^^^^
                                   1 1101 0011

0x1d3 & 0x1f = 0x13 -> Supervisor (SVC) mode
0x1d3 & 0xc0 = 0xc0 -> IRQ and FIQ disabled
State ARM
NZCV flags are set to 0
----

==== üìç Locate the start of physical memory

After saving the ATAGS and Arch ID, we will execute the decompression routine.So now the kernel decompression code is executing from the physical address of the physical memory where it was loaded.

The decompression code then locates the start of physical memory. On most modern platforms this is done with the Kconfig-selected code AUTO_ZRELADDR, which means a logical AND between the program counter and 0xf8000000. This means that the kernel readily assumes that it has been loaded and executed in the first part of the first block of physical memory.

image::find-physical-memory.png[]

once instructions are excuted, we know the starting address of the physical memory.

[source,instructions]
----
mov	r0, pc
and	r0, r0, #0xf8000000
----

image::find-phy-addr.png[]

`0x40000000` is the starting address of the physical memory.

The kernel image is loaded somewhere in physical memory, often by a bootloader (U-Boot, or in some old systems, Angel).The kernel doesn't know the exact load address yet. But it needs a base address for:

* Setting up the stack (sp)
* Copying itself to the proper location
* Accessing global data and relocation info
So early boot uses PC-relative addressing to calculate a safe "kernel base" address.

The decompression code needs a base address to work from, because it will eventually:

* Copy itself to the right place
* Set up the stack
* Jump into C code

[source,calculation]
----
0xf8000000 = 1111 1000 0000 0000 0000 0000 0000 0000
Top 5 bits = physical memory block
Lower 27 bits = offset within the block
----

*So pc & 0xf8000000 keeps the first 32MB-aligned block of memory*

*Example*

Suppose kernel is loaded at:
PC = 0x400100a4
Compute:
0x400100a4 & 0xf8000000 = 0x40000000
0x40000000 ‚Üí kernel base address
All PC-relative offsets can now be computed from here safely.

==== üìä Calculate stack top address

. Below instructions are from head.S file which takes care of stack top address calculation.
+
[source,instruction]
----
adr r1, LC1
ldr sp, [r1]    @ get stack location
add sp, sp, r1  @ apply relocation
----

. To understand the LC1 label we will use objdump.
+
[source,instruction]
----
arm-poky-linux-gnueabi-objdump -D arch/arm/boot/compressed/vmlinux |less

ADDRESS <symbol_name>:
   OFFSET:   MACHINE_CODE    DISASSEMBLED_INSTRUCTION
----

image::LC0-LC1.png[]

This instruction from head.S will be converted to

image::of-use.png[]

Now here current instruction address is `0x400100a8` and Value of pc during execution is `0x400100a8 + 8 = 0x400100b0`. Add `   0x200` to it to get the final value **0x400102b0**.

image::stack-location.png[]

image::stack-location-gdb.png[]

[source,instruction]
----
add r1, pc, #512    @ r1 = PC + 0x200
----

Here is the values of r1 and PC register before execution of first instruction. We can see that r1 address is `0x400102b0` which is matching with the value in the objdump output LC1: 0x000002b0

image::of-use-1.png[]

[source,instruction]
----
ldr sp, [r1]         @ sp = [r1]
----

Here is the value of sp register after execution of above instruction.

image::sp-before-relocation.png[]

At this point in GDB, we have just done the ldr sp, [r1], but not yet the relocation (add sp, sp, r1)
That's why SP = 0x9faa10 ‚Üí it is the offset read from memory, not the final absolute address.

image::sp-after-relocation.png[]

Now we have the final absolute address of the stack.

```bash
sp_final = 0x009faa10 + 0x400102b0
         = 0x40a0acc0
```

Stack caluculation was bit tricky to undestand and that's why I am adding more details to it.

**LC1 and .L_user_stack_end Offset Analysis (ARM zImage Decompressor)**

`.L_user_stack_end` is *not* a linker symbol.

It is a **local assembler label** defined in `head.S`.

Instead, its value is derived from the end of the `.stack` section.

The LC1 object stores *relative offsets*:

----
LC1[0] = .L_user_stack_end - LC1
LC1[1] = _edata - LC1
----

At runtime:

----
real_address = LC1_address + stored_offset
----

This allows the decompressor to remain fully position-independent.

---

*Section Layout (readelf)*

Command:

----
arm-poky-linux-gnueabi-readelf -S arch/arm/boot/compressed/vmlinux
----

Output:

----
There are 24 section headers, starting at offset 0xa17c04:

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 001000 006368 00  AX  0   0 32
  [ 2] .table            PROGBITS        00006368 007368 00001c 00  WA  0   0  4
  [ 3] .rodata           PROGBITS        00006384 007384 000da8 00   A  0   0  4
  [ 4] .piggydata        PROGBITS        0000712c 00812c 9f2b47 00   A  0   0  1
  [ 5] .got.plt          PROGBITS        009f9c74 9fac74 00000c 04  WA  0   0  4
  [ 6] .got              PROGBITS        009f9c80 9fac80 000024 00  WA  0   0  4
  [ 7] .pad              PROGBITS        009f9ca4 9faca4 000004 00   A  0   0  1
  [ 8] .bss              NOBITS          009f9ca8 9faca8 000018 00  WA  0   0  4
  [ 9] .stack            NOBITS          009f9cc0 9faca8 001000 00  WA  0   0  1
----

Important values:

----
.stack Addr = 0x009f9cc0
.stack Size = 0x1000
----

Therefore:

----
.L_user_stack_end = 0x009f9cc0 + 0x1000
                 = 0x009facc0
----

*Symbol Lookup (nm)*

Commands:

----
arm-poky-linux-gnueabi-nm -n arch/arm/boot/compressed/vmlinux |grep LC1
----

Output:

----
000002b0 t LC1
----

Additional symbols:

----
arm-poky-linux-gnueabi-nm -n arch/arm/boot/compressed/vmlinux |egrep "LC1|_edata|_start"
----

Output:

----
00000000 T _magic_start
00000000 T _start
000002b0 t LC1
00005cec T fdt_check_mem_start
00006368 D _table_start
009f9c80 D _got_start
009f9ca8 B __bss_start
009f9ca8 R _edata
009f9ca8 R _edata_rea
----

So:

----
LC1     = 0x000002b0
_edata  = 0x009f9ca8
----

Compute:

----
_edata - LC1 = 0x009f9ca8 - 0x2b0 = 0x009f99f8
----

*Raw LC1 Contents (objdump)*

Command:

----
arm-poky-linux-gnueabi-objdump -s -j .text arch/arm/boot/compressed/vmlinux |grep "02b0 "
----

Output:

----
 02b0 10aa9f00 f8999f00 e4dbaf00 b3999f00  ................
----

Little endian decoding:

----
Word0 = 0x009faa10
Word1 = 0x009f99f8
----

*LC1 Disassembly Context*

Command:

----
arm-poky-linux-gnueabi-objdump -D arch/arm/boot/compressed/vmlinux |grep -A6 LC1
----

Output:

----
      c8:       359f01e8        ldrcc   r0, [pc, #488]  @ 2b8 <LC1+0x8>
      cc:       3080000f        addcc   r0, r0, pc
      d0:       31540000        cmpcc   r4, r0
      d4:       33844001        orrcc   r4, r4, #1
      d8:       2b000078        blcs    2c0 <cache_on>

000000dc <restart>:
--
000002b0 <LC1>:
     2b0:       009faa10
     2b4:       009f99f8
     2b8:       00afdbe4
     2bc:       009f99b3

000002c0 <cache_on>:
----

*Stack Offset Calculation*

From earlier:

----
.L_user_stack_end = 0x009facc0
LC1               = 0x000002b0
----

Compute:

----
.L_user_stack_end - LC1
= 0x009facc0 - 0x2b0
= 0x009faa10
----

This matches LC1[0]:

----
009faa10
----

*Final Interpretation of LC1*

LC1 contains:

----
LC1[0] = 0x009faa10  -> (.L_user_stack_end - LC1)
LC1[1] = 0x009f99f8  -> (_edata - LC1)
----

At runtime:

----
sp = LC1 + LC1[0]
r6 = LC1 + LC1[1]
----

Which reconstructs:

* stack top
* end of image

without absolute addresses.

Final values for this build:

----
.stack Addr = 0x009f9cc0
.stack Size = 0x1000

.L_user_stack_end = 0x009facc0
LC1 = 0x2b0

Stack Offset = 0x009faa10
_edata Offset = 0x009f99f8
----

Everything matches exactly.

==== ‚è≠Ô∏è fdt_check_mem_start

Traditionally, the start address of physical memory is obtained by masking the program counter.  However, this does require that this address is a multiple of 128 MiB, precluding booting Linux on platforms where this requirement is not fulfilled. Hence validate the calculated address against the memory information in the DTB, and, if out-of-range, replace it by the real start address. To preserve backwards compatibility (systems reserving a block of memory at the start of physical memory, kdump, ...), the traditional method is always used if it yields a valid address.

0x48000000 is the fdt location passed as ATAGs. If we dump this location, we get:

image::../images/fdt-mem-check.png[]

first word is 0xedfe0dd0 which is byte-swapped magic number for fdt in fdt header.
----
0xedfe0dd0  -> 0xd00dfeed  ‚úÖ
----

image::../images/memory-address.png[]

==== Determine final kernel image address

* These are the instructions from head.S which adds the TEXT_OFFSET to the physical address(0x40000000).

We have the kernel base address now. Next step is to add the TEXT_OFFSET to it to get the kernel base address.
Then the TEXT_OFFSET is added to the pointer to the start of physical memory. As the name says, this is where the kernel .text segment (as output from the compiler) should be located. The .text segment contains the executable code so this is the actual starting address of the kernel after decompression. This is defined in arch/arm/Makefile.

-----
		/* Determine final kernel image address. */
	add	r4, r0, #TEXT_OFFSET
#else
		ldr	r4, =zreladdr
#endif
-----

image::textofs.png[]

image::../images/text-offset.png[]

For some specific platforms the TEXT_OFFSET will be pushed downwards in memory, notably some Qualcomm platforms will push it to `0x00208000` because the first `0x00200000` (2 MB) of the physical memory is used for shared memory communication with the modem CPU.

----
(gdb) info registers r4 r0
r4             0x40208000          1075871744
r0             0x40000000          1073741824
(gdb) 
----

`r4` = `r0` + `TEXT_OFFSET` = `0x40000000` + `0x208000` = `0x40208000`

so the kernel will be located at `0x40208000`

==== Setup page tables for cache only

Next the decompression code sets up a page table, if it is possible to fit one over the whole uncompressed+compressed kernel image. The page table is not for virtual memory, but for enabling cache, which is then turned on. The decompression will for natural reasons be much faster if we can use cache.

Set up a page table only if it won't overwrite ourself.That means `r4` < `pc` || `r4` - 16k page directory > `&_end`.Given that `r4` > `&_end` is most unfrequent, we add a rough additional 1MB of room for a possible appended DTB.

* Here r0 is the PC and r4 is the address with TEXT_OFFSET.

----
(gdb) info registers r0 r4
r0             0x400100c8          1073807560
r4             0x40208000          1075871744
(gdb)
----

==== sets up a local stack pointer

The kernel sets up a local stack pointer and malloc() area so we can handle subroutine calls and small memory allocation going forward, executing code written in C. This is set to point right after the end of the kernel image.

----
(gdb) info registers pc r0
pc             0x400100e0          0x400100e0 <restart+4>
r0             0x400102b0          1073808048
(gdb) 
----

Address of LC1 is `0x400102b0` and PC is `0x400100e0`. `0x400102b0` looks familiar, it is the same address as the stack pointer in the previous section where LC1 was calculated.

image::../images/stack-ptr-lc1.png[]

Now `sp` is pointing to the TOP of the stack

==== malloc() area

* malloc space is above the relocated stack (64k max)

----
/* malloc space is above the relocated stack (64k max) */
=> 0x40010118 <restart+60>:     add     r10, sp, #65536 @ 0x10000
---- 

----
(gdb) info registers r10 sp
r10            0x40a1acc0          1084337344
sp             0x40a0acc0          0x40a0acc0
(gdb) 
----

`sp` + `0x10000` = `0x40a1acc0`

==== check for an appended DTB blob

This is not enabled in our case. CONFIG_ARM_APPENDED_DTB should be enabled to use this feature.

==== Check to see if we will overwrite ourselves

We basically want:

*   r4 - 16k page directory >= r10 -> OK
*   r4 + image length <= address of wont_overwrite -> OK
* Note: the possible LSB in r4 is harmless here.

----
0x40010120 <restart+68>:     add     r10, r10, #16384        @ 0x4000
0x40010124 <restart+72>:     cmp     r4, r10
0x40010128 <restart+76>:     bcs     0x400101b4 <wont_overwrite>
0x4001012c <restart+80>:     add     r10, r4, r9
0x40010130 <restart+84>:     add     r9, pc, #124    @ 0x7c
0x40010134 <restart+88>:     cmp     r10, r9
0x40010138 <restart+92>:     bls     0x400101b4 <wont_overwrite>
----

*   `r4` = final kernel address (possibly with LSB set)
*   `r9` = size of decompressed image
*   `r10` = end of this image, including  bss/stack/malloc space if non XIP

----
(gdb) info registers r9 r4 r10
r9             0x1971d2c           26680620
r4             0x40208001          1075871745
r10            0x40a1acc0          1084337344
(gdb) 
----

*TBD*